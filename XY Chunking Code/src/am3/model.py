"""
Defines various object models used throughout the library. These include:

    * Chunk
    * Slice
    * Path
"""

from typing import Union, List
import bpy
from mathutils import Vector


class Path:
    """
    Represents a path for an extruder to follow (i.e. a printable path). Path objects will almost
    always contain points that are horizontally coplanar to every other point in the path.
    """

    vertices = []
    """
    This list of vertices that comprise this path

    :type: List[Vector]
    """

    def __init__(self):
        self.vertices = []

    def __getitem__(self, index):
        return self.vertices[index]

    def __setitem__(self, index, item):
        self.vertices[index] = item

    def __iter__(self):
        return self.vertices.__iter__()

    def append(self, item):
        """
        Appends ``item``  to ``self.vertices``. If ``item`` is a Vector, then ``item`` is appended
        normally. If ``item`` is a List[Vector], then the contents of ``item`` are each appended.

        :param item: a Vector or List of Vectors
        :type item: Vector or List[Vector]
        """
        if isinstance(item, list):
            for sub_item in item:
                self.vertices.append(sub_item)
        else:
            self.vertices.append(item)


class Slice:
    """
    Represents a slice in a Chunk. A slice is a list of printable paths that exist in the same
    horizontal plane. Thus, this class is essentailly a wrapper around a list of
    :class:`~am3.model.Path` objects.
    """

    paths = []
    """
    This list of Paths that comprise this Slice.

    :type: List[Path]
    """

    def __init__(self):
        self.paths = []

    def __getitem__(self, index):
        return self.paths[index]

    def __setitem__(self, index, item):
        self.paths[index] = item

    def __iter__(self):
        return self.paths.__iter__()

    def append(self, item: Union[Path, List[Path]]):
        """
        Appends ``item``  to ``self.paths``. If ``item`` is a Path, then ``item`` is appended
        normally. If ``item`` is a List[Path], then the contents of ``item`` are each appended.

        :param item: a Path or List of Paths
        :type item: Path or List[Path]
        """

        if isinstance(item, list):
            for sub_item in item:
                self.paths.append(sub_item)
        else:
            self.paths.append(item)


class Chunk:
    """
    Defines a model for representing a chunk in AM3 Cooperative 3D Printing. Chunks can either be
    empty or non-empty. Non-empty chunks have a corresponding Blender model in the scene with
    ``volume > 0``. Empty chunks exist because of irregularly shaped models. If a chunk is empty,
    it is still critical that its owning robot moves to where that chunk `would` have been. If
    the robot does not go to the empty Chunk's location, then other robots will likely collide
    with it.
    """

    model = None
    """
    The Blender object this Chunk represents. If the Chunk is empty, then this variable will be a
    Vector. The robot will need to move to this Vector when it comes time to simulate printing
    this Chunk, as opposed to printing the sliced model.

    :type: bpy.types.Object or Vector
    """

    number = -1
    """
    This chunk's number. This is very important for managing dependencies properly.

    :type: int
    """

    dependencies = []
    """
    The chunk numbers upon which this Chunk depends.

    :type: List[int]
    """

    slices = []
    """
    The slices generated by the Slicer for this Chunk.

    :type: List[Slice]
    """

    commands = []
    """
    The commands generated by the Robot from ``self.slices`` for this Chunk.

    :type: List[object]
    """

    color = (255, 255, 255)
    """
    The material color that should be used to print this Chunk.

    :type: Tuple[int, int, int]
    """

    execution_time = -1
    """
    The length of time (in frames) needed to execute this chunk. This will always be equal to
    ``len(self.frame_data)``, but it's more accessible to have a dedicated member for this.

    :type: int
    """

    frames = []
    """
    The List of ChunkFrame objects used to render this Chunk.

    :type: List[ChunkFrame]
    """

    def __init__(self, model: bpy.types.Object, number: int = -1):
        """
        Constructs a new Chunk object.

        :param model: the Blender model this Chunk represents.
        :type model: bpy.types.Object
        :param number: the unique number to assign to this chunk. Chunk numbers should be distinct
            and consecutive (i.e. no \"missing numbers\")
        :type number: int
        """

        self.model = model
        self.row = 0
        self.number = number
        self.dependencies = []
        self.slices = []
        self.commands = []
        self.color = (255, 255, 255)
        self.execution_time = -1
        self.frames = []

    def __getitem__(self, index):
        return self.slices[index]

    def __setitem__(self, index, item):
        self.slices[index] = item

    def __iter__(self):
        return self.slices.__iter__()

    def append(self, item: Union[Slice, List[Slice]]):
        """
        Appends the ``item`` argument to the ``self.slices``. If ``item`` is a list, then its
        contents are appended to ``self.slices``. Otherwise, ``item`` should be a Slice, and
        it is appended to ``self.slices``.

        :param item: the Slice or List[Slice] to append
        :type item: Slice or List[Slice]
        """
        if isinstance(item, list):
            for sub_item in item:
                self.slices.append(sub_item)
        else:
            self.slices.append(item)

    def set_name(self, name: str):
        """
        Sets the name of the Blender model for this Chunk to ``name``, if it exists.

        :param name: the new name for the Blender model.
        :type name: str
        """

        if not self.is_empty():
            self.model.name = name

    def set_hidden(self, hidden: bool):
        """
        Hides or unhides this model depending on the value of ``hidden``.

        :param hidden: pass ``True`` to hide the model, ``False`` otherwise.
        :type hidden: bool
        """

        if not self.is_empty():
            self.model.hide = hidden

    def add_dependency(self, item: Union[int, List[int]]):
        """
        Appends the value ``item`` (or, if ``item`` is a List, the values in ``item``) to this
        Chunk's dependencies.

        :param item: a chunk number (or List of chunk numbers) to add to this Chunk's dependencies.
        :type item: int or List[int]
        """

        if isinstance(item, list):
            for value in item:
                self.dependencies.append(value)
        else:
            self.dependencies.append(item)

    def dependencies_satisfied(self, finished_chunk_numbers: List[int]) -> bool:
        """
        Checks if all of the dependencies for this chunk have been finished (i.e., each value in
        ``self.dependencies`` is also in ``finished_chunks``).

        :param finished_chunks: a List of all the chunks that have been printed already
        :type finished_chunks: List[int]
        :return: whether or not all of ``self.dependencies`` are satisfied
        :rtype: bool
        """

        for dependency in self.dependencies:
            if dependency not in finished_chunk_numbers:
                return False
        return True

    def is_empty(self) -> bool:
        """
        Indicates whether or not this Chunk is \"empty\". A chunk is empty if its model had no
        polygons in its mesh at chunk-time. When this is discovered, ``self.model`` is set to
        a Vector object.

        :return: if this Chunk is empty
        :rtype: bool
        """

        return isinstance(self.model, Vector)

    def get_min_position(self) -> float:
        """
        :return: the minimum Z position of this Chunk, according to the points in ``self.slices``.
        :rtype: float
        """

        min_z = 0
        for chunk_slice in self.slices:
            for path in chunk_slice.paths:
                for vertex in path.vertices:
                    if vertex[2] < min_z:
                        min_z = vertex[2]
        return min_z

    def shift_paths(self, z_position: float):
        """
        Shifts every point's Z position in the sliced Chunk (i.e., ``chunk.slices``) by
        ``z_position``.

        :param z_position: the amount to shift
        :type z_position: float
        """

        for chunk_slice in self.slices:
            for path in chunk_slice.paths:
                for i in range(0, len(path.vertices)):
                    vertex = path.vertices[i]
                    x = vertex[0]
                    y = vertex[1]
                    z = vertex[2] + z_position
                    new_vertex = Vector((x, y, z))
                    path.vertices[i] = new_vertex
